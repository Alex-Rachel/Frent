using Frent.Variadic.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Buffers;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace Frent.Generator;

[Generator(LanguageNames.CSharp)]
public class ComponentUpdateTypeRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)   
    {
        var models = context.SyntaxProvider.CreateSyntaxProvider(static (n, _) => n is TypeDeclarationSyntax typeDec && typeDec.BaseList is not null,
            static (gsc, _) =>
            {
                INamedTypeSymbol? symbol = gsc.SemanticModel.GetDeclaredSymbol(gsc.Node) as INamedTypeSymbol;

                if (symbol is not null)
                {
                    foreach (var @interface in symbol.AllInterfaces)
                    {
                        if (InterfaceImplementsIComponent(@interface))
                        {
                            string @namespace = symbol.ContainingNamespace.ToString();
                            int index = @namespace.IndexOf('.');
                            var genericArgs = @interface.TypeArguments.Length == 0 ? Array.Empty<string>() : new string[@interface.TypeArguments.Length];

                            for(int i = 0; i < @interface.TypeArguments.Length; i++)
                                genericArgs[i] = @interface.TypeArguments[i].ToString();


                            return new ComponentUpdateItemModel(
                                symbol.Name,
                                @interface.Name,
                                index == -1 ? @namespace : @namespace.Substring(0, index),
                                index == -1 ? string.Empty : @namespace.Substring(index + 1), 
                                new EquatableArray<string>(genericArgs));
                        }
                    }
                }

                return new ComponentUpdateItemModel(string.Empty, string.Empty, string.Empty, string.Empty, new EquatableArray<string>(Array.Empty<string>()));
            });

        IncrementalValuesProvider<(string Name, string Source)> file = models
            .Where(m => m.Type.Length != 0)
            .Select(GenerateFiles);

        context.RegisterImplementationSourceOutput(file, (ctx, s) => ctx.AddSource(s.Name, s.Source));
    }

    private static (string Name, string Source) GenerateFiles(ComponentUpdateItemModel model, CancellationToken ct)
    {
        StringBuilder sb = new StringBuilder();

        var span = ExtractUpdaterName(model.ImplInterface);

        sb
            .AppendLine("// <auto-generated />")
            .AppendLine("// This file was auto generated using Frent's source generator")
            .AppendLine("using Frent.Updating;")
            .AppendLine("using System.Runtime.CompilerServices;")
            .AppendLine()
            .Append("namespace ").Append(model.BaseNamespace).Append(';').AppendLine()
            .AppendLine()
            .Append("internal static class ").Append(model.Type).AppendLine("ComponentUpdateInitalizer_")
            .AppendLine("{")
                .AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]")
                .Append("    internal static void Initalize() => Frent.Updating.GenerationServices.RegisterType(typeof(")
                    .Append(model.SubNamespace).Append('.').Append(model.Type).Append("), new Frent.Updating.Runners."); 
            (span.Count == 0 ? sb.Append("None") : sb.Append(model.ImplInterface, span.Start, span.Count)).Append("RunnerFactory").Append('<').Append(model.SubNamespace).Append('.').Append(model.Type);

        foreach(var item in model.GenericArguments)
            sb.Append(", ").Append(item);

        sb.AppendLine(">());").AppendLine("}");

        string source = sb.ToString();
        sb.Clear();

        sb.Append(model.SubNamespace).Append('.').Append(model.Type).Append("ComponentUpdateInitalizer").Append(".g.cs");

        string name = sb.ToString();
        sb.Clear();

        return (name, source);

        static (int Start, int Count) ExtractUpdaterName(string interfaceName)
        {
            return (1, interfaceName.Length - "IComponent".Length);
        }
    }


    static bool Launched = false;

    [Conditional("DEBUG")]
    [DebuggerStepThrough]
    [DebuggerHidden]
    internal static void LaunchDebugger()
    {
        if (!Debugger.IsAttached && !Launched)
            Debugger.Launch();
        Launched = true;
    }

    private static bool InterfaceImplementsIComponent(INamedTypeSymbol namedTypeSymbol) => 
        (namedTypeSymbol.Interfaces.Length == 1 && 
        namedTypeSymbol.Interfaces[0].ConstructedFrom.ToString() == RegistryConstants.TargetInterfaceName) ||
        namedTypeSymbol.Interfaces.Length == 0 && 
        namedTypeSymbol.ConstructedFrom.ToString() == RegistryConstants.TargetInterfaceName;

    internal record struct ComponentUpdateItemModel(string Type, string ImplInterface, string BaseNamespace, string SubNamespace, EquatableArray<string> GenericArguments);
}